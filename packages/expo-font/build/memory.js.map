{"version":3,"file":"memory.js","sourceRoot":"","sources":["../src/memory.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,MAAM,YAAY,GAAsC,EAAE,CAAC;AAElE,8EAA8E;AAC9E,4EAA4E;AAC5E,4EAA4E;AAC5E,6DAA6D;AAC7D,MAAM,MAAM,GAAgC,EAAE,CAAC;AAE/C,MAAM,QAAQ,GAAG,GAAgC,EAAE;IACjD,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,UAAU,GAAG,CAAC,UAAkB,EAAE,EAAE;IAC/C,QAAQ,EAAE,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;AAChC,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,eAAe,GAAG,CAAC,UAAkB,EAAE,EAAE;IACpD,OAAO,UAAU,IAAI,QAAQ,EAAE,CAAC;AAClC,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,cAAc,GAAG,CAAC,UAAkB,EAAE,EAAE;IACnD,IAAI,eAAe,CAAC,UAAU,CAAC,EAAE;QAC/B,OAAO,IAAI,CAAC;KACb;SAAM;QACL,MAAM,WAAW,GAAG,QAAQ,EAAE,CAAC;QAC/B,uEAAuE;QACvE,oFAAoF;QACpF,4EAA4E;QAC5E,aAAa;QACb,MAAM,iBAAiB,GAAa,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE,WAAW,IAAI,EAAE,CAAC;QAC1F,iBAAiB,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YACjC,WAAW,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;QAC3B,CAAC,CAAC,CAAC;QACH,OAAO,UAAU,IAAI,WAAW,CAAC;KAClC;AACH,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,UAAU,GAAG,CAAC,UAAmB,EAAE,EAAE;IAChD,MAAM,MAAM,GAAG,QAAQ,EAAE,CAAC;IAC1B,MAAM,WAAW,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACpE,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;QACpC,OAAO,MAAM,CAAC,UAAU,CAAC,CAAC;KAC3B;AACH,CAAC,CAAC","sourcesContent":["export const loadPromises: { [name: string]: Promise<void> } = {};\n\n// cache the value on the js side for fast access to the fonts that are loaded\n// we do not delete cache entries because font unloading is not a public api\n// TODO vonovak use global object cache so that it can be used elsewhere too\n// globalThis.expo.modules.ExpoFontLoader.loadedCache ??= {};\nconst _cache: { [name: string]: boolean } = {};\n\nconst getCache = (): { [name: string]: boolean } => {\n  return _cache;\n};\n\nexport const markLoaded = (fontFamily: string) => {\n  getCache()[fontFamily] = true;\n};\n\nexport const isLoadedInCache = (fontFamily: string) => {\n  return fontFamily in getCache();\n};\n\nexport const isLoadedNative = (fontFamily: string) => {\n  if (isLoadedInCache(fontFamily)) {\n    return true;\n  } else {\n    const loadedCache = getCache();\n    // TODO vonovak mock `loadedFonts` (optional is used only bcs of tests)\n    // we're using global instead of the native module - this global is not a public api\n    // but is meant to be consumed outside of Expo (community package) if needed\n    // @ts-ignore\n    const loadedNativeFonts: string[] = global.expo.modules.ExpoFontLoader?.loadedFonts || [];\n    loadedNativeFonts.forEach((font) => {\n      loadedCache[font] = true;\n    });\n    return fontFamily in loadedCache;\n  }\n};\n\nexport const purgeCache = (fontFamily?: string) => {\n  const loaded = getCache();\n  const keysToPurge = fontFamily ? [fontFamily] : Object.keys(loaded);\n  for (const fontFamily of keysToPurge) {\n    delete loaded[fontFamily];\n  }\n};\n"]}